---
id: solid
title: SOLID - Принципы объектно-ориентированного программирования
sidebar_label: SOLID
sidebar_position: 4
description: Применение принципов SOLID
keywords:
  - SOLID
  - объектно-ориентированное программирование
  - SRP
  - OCP
  - LSP
  - ISP
  - DIP
  - принципы программирования
slug: /developer-principles/solid
---

**SOLID** - это аббревиатура, которая объединяет пять основных принципов объектно-ориентированного проектирования и программирования. Несмотря на то, что платформа 1С не является полностью объектно-ориентированной, эти принципы могут быть адаптированы для более эффективной разработки.

:::info Что такое SOLID?
**S** - Single Responsibility Principle (Принцип единственной ответственности)  
**O** - Open/Closed Principle (Принцип открытости/закрытости)  
**L** - Liskov Substitution Principle (Принцип подстановки Лисков)  
**I** - Interface Segregation Principle (Принцип разделения интерфейса)  
**D** - Dependency Inversion Principle (Принцип инверсии зависимостей)  
:::

## S - Single Responsibility Principle (Принцип единственной ответственности) {#single-responsibility}

### Описание

Каждый класс должен иметь только одну причину для изменения. Иными словами, каждый модуль, общий модуль, форма или процедура должны отвечать только за одну функциональность.

### Применение

- Разделяйте обработчики событий форм и бизнес-логику
- Выносите логику в отдельные модули по их назначению (работа с файлами, обработка данных и т.д.)
- Создавайте отдельные общие модули для различных аспектов бизнес-логики

### Пример

```bsl
// Плохо: смешивание ответственностей
Процедура ОбработатьЗаказ(Заказ)
    // Расчет суммы
    СуммаДокумента = 0;
    Для Каждого Строка Из Заказ.Товары Цикл
        СуммаДокумента = СуммаДокумента + Строка.Сумма;
    КонецЦикла;
    
    // Отправка email
    Письмо = Новый ИнтернетПочтовоеСообщение;
    Письмо.Тема = "Новый заказ";
    Письмо.Текст = "Сумма заказа: " + СуммаДокумента;
    // Отправка письма...
    
    // Запись в журнал
    ЗаписьЖурнала = Новый ЗаписьЖурналаРегистрации("Заказы");
    ЗаписьЖурнала.Записать("Обработан заказ на сумму " + СуммаДокумента);
КонецПроцедуры;

// Хорошо: разделение ответственностей
Функция РассчитатьСуммуЗаказа(Заказ)
    СуммаДокумента = 0;
    Для Каждого Строка Из Заказ.Товары Цикл
        СуммаДокумента = СуммаДокумента + Строка.Сумма;
    КонецЦикла;
    
    Возврат СуммаДокумента;
КонецФункции;

Процедура ОтправитьУведомлениеОЗаказе(Заказ, Сумма)
    Письмо = Новый ИнтернетПочтовоеСообщение;
    Письмо.Тема = "Новый заказ";
    Письмо.Текст = "Сумма заказа: " + Сумма;
    // Отправка письма...
КонецПроцедуры;

Процедура ЗаписатьВЖурнал(Сообщение)
    ЗаписьЖурнала = Новый ЗаписьЖурналаРегистрации("Заказы");
    ЗаписьЖурнала.Записать(Сообщение);
КонецПроцедуры;

Процедура ОбработатьЗаказ(Заказ)
    Сумма = РассчитатьСуммуЗаказа(Заказ);
    ОтправитьУведомлениеОЗаказе(Заказ, Сумма);
    ЗаписатьВЖурнал("Обработан заказ на сумму " + Сумма);
КонецПроцедуры;
```

## O - Open/Closed Principle (Принцип открытости/закрытости) {#open-closed}

### Описание

Программные сущности должны быть открыты для расширения, но закрыты для модификации. То есть, поведение сущности можно расширить без изменения её исходного кода.

### Применение

- Используйте расширения конфигурации вместо изменения типовых решений
- Применяйте механизмы подписок на события
- Используйте шаблоны проектирования, позволяющие расширять функциональность без изменения существующего кода

### Пример

```bsl
// Плохой подход: прямое изменение модуля документа при добавлении нового функционала
// В модуле документа ПоступлениеТоваров:
Процедура ОбработкаПроведения(Отказ, Режим)
    // Существующий код проведения...
    
    // Добавляем новую функциональность прямо в документ
    Если ЭтоНовыйФункционал Тогда
        // Код для нового функционала
    КонецЕсли;
КонецПроцедуры;

// Хороший подход: использование подписок на события
// В отдельном модуле расширения:
Процедура ПриПроведенииДокумента(Источник, Отказ, РежимПроведения) Экспорт
    Если ТипЗнч(Источник) = Тип("ДокументОбъект.ПоступлениеТоваров") Тогда
        // Новая функциональность без изменения исходного кода документа
        ОбработатьНовыйФункционал(Источник);
    КонецЕсли;
КонецПроцедуры;
```

:::tip Практическое применение
В 1С:Предприятие этот принцип особенно важен при работе с типовыми конфигурациями. Использование расширений вместо изменения базовой конфигурации значительно упрощает обновление типовых решений.
:::

## L - Liskov Substitution Principle (Принцип подстановки Лисков) {#liskov-substitution}

### Описание

Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения корректности программы.

### Применение

- При наследовании форм и объектов метаданных сохраняйте ожидаемое поведение
- Придерживайтесь согласованных интерфейсов между похожими объектами
- При переопределении методов в расширениях сохраняйте исходную функциональность

### Пример

```bsl
// Общий модуль с интерфейсом для работы с документами
Функция ПолучитьСуммуДокумента(Документ) Экспорт
    // Абстрактный метод, который должен быть переопределен
    ВызватьИсключение "Метод должен быть переопределен";
КонецФункции;

// Реализация для документа ПоступлениеТоваров
Функция ПолучитьСуммуПоступления(Документ) Экспорт
    Возврат Документ.СуммаДокумента;
КонецФункции;

// Реализация для документа РеализацияТоваров
Функция ПолучитьСуммуРеализации(Документ) Экспорт
    // Нарушение принципа Лисков - изменение ожидаемого поведения
    Возврат Документ.Товары.Итог("Сумма");  // Возвращает другое значение
КонецФункции;

// Правильная реализация для РеализацияТоваров
Функция ПолучитьСуммуРеализацииПравильно(Документ) Экспорт
    // Соблюдение принципа Лисков - сохранение ожидаемого поведения
    Возврат Документ.СуммаДокумента;  // Возвращает то же значение, что и для поступления
КонецФункции;
```

## I - Interface Segregation Principle (Принцип разделения интерфейса) {#interface-segregation}

### Описание

Много специализированных интерфейсов лучше, чем один универсальный. Клиенты не должны зависеть от интерфейсов, которые они не используют.

### Применение

- Разделяйте общие модули по функциональному назначению
- Используйте параметризированные обработки для конкретных задач вместо универсальных решений "всё в одном"
- Создавайте небольшие специализированные формы и отчеты вместо громоздких универсальных

### Пример

```bsl
// Плохо: универсальный интерфейс со множеством методов
// Общий модуль РаботаСДокументами:
Процедура ОтправитьДокументПоПочте(Документ) Экспорт
    // Реализация...
КонецПроцедуры;

Процедура ПровестиДокумент(Документ) Экспорт
    // Реализация...
КонецПроцедуры;

Процедура СформироватьПечатнуюФорму(Документ) Экспорт
    // Реализация...
КонецПроцедуры;

Процедура ВыгрузитьВБухгалтерию(Документ) Экспорт
    // Реализация...
КонецПроцедуры;

// Хорошо: разделение на специализированные интерфейсы
// Общий модуль РаботаСЭлектроннойПочтой:
Процедура ОтправитьДокументПоПочте(Документ) Экспорт
    // Реализация...
КонецПроцедуры;

// Общий модуль ПечатныеФормы:
Процедура СформироватьПечатнуюФорму(Документ) Экспорт
    // Реализация...
КонецПроцедуры;

// Общий модуль ВыгрузкаВБухгалтерию:
Процедура ВыгрузитьВБухгалтерию(Документ) Экспорт
    // Реализация...
КонецПроцедуры;
```

## D - Dependency Inversion Principle (Принцип инверсии зависимостей) {#dependency-inversion}

### Описание

Зависимость на абстракциях, а не на конкретных реализациях. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба должны зависеть от абстракций.

### Применение

- Используйте общие интерфейсы для взаимодействия между модулями
- Применяйте механизм подписок на события для уменьшения прямых зависимостей
- Используйте функциональные опции для конфигурирования поведения

### Пример

```bsl
// Плохо: прямая зависимость от реализации
Процедура ОтправитьУведомление(Данные)
    // Прямая зависимость от конкретной реализации
    ОтправкаSMS.ОтправитьСообщение(Данные.Телефон, Данные.Текст);
КонецПроцедуры;

// Хорошо: зависимость от абстракции
Процедура ОтправитьУведомление(Данные, СервисОтправки)
    // Зависимость от абстракции (интерфейса)
    СервисОтправки.ОтправитьСообщение(Данные);
КонецПроцедуры;

// Использование:
// СервисSMS = СервисыОтправкиСообщений.ПолучитьСервисSMS();
// ОтправитьУведомление(Данные, СервисSMS);
// или
// СервисEmail = СервисыОтправкиСообщений.ПолучитьСервисEmail();
// ОтправитьУведомление(Данные, СервисEmail);
```

## Применение SOLID в 1С {#applying-solid}

Хотя платформа 1С имеет свои особенности и ограничения, принципы SOLID могут существенно повысить качество кода и упростить его сопровождение. При этом важно применять эти принципы гибко, с учетом специфики платформы и решаемых задач.

:::info Преимущества применения SOLID в 1С

- Повышение модульности и расширяемости кода
- Упрощение тестирования и отладки
- Снижение связанности компонентов
- Более эффективная командная разработка
- Упрощение сопровождения и масштабирования решений

:::

## Дополнительные ресурсы {#additional-resources}

- [Описание SOLID на Wikipedia](https://ru.wikipedia.org/wiki/SOLID_(объектно-ориентированное_программирование))
- [Использование принципов SOLID в разработке на 1С](https://infostart.ru/1c/articles/2172468/)
- [Видео: Александр Пузаков. Использование принципов SOLID в разработке на 1С](https://infostart.ru/video/w2172507/)

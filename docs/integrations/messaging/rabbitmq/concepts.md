---
sidebar_position: 1
---

# Основные концепции

## Модель обмена сообщениями

**Producer** отправляет сообщения в **Exchange**, а не напрямую в очередь. Exchange маршрутизирует сообщения в **Queue** на основе **Binding**.

### Процесс работы

1. Producer отправляет сообщение в Exchange
2. Exchange маршрутизирует сообщение в одну или несколько Queue по правилам Binding
3. Queue хранит ссылку на сообщение (в памяти или на диске)
4. Consumer получает копию сообщения из Queue
5. Consumer отправляет подтверждение (ack)
6. Брокер удаляет сообщение после получения подтверждения

## Exchange (Точка обмена)

Получает сообщения от издателей и распределяет их в очереди на основе Binding.

### Особенности

- Не является Erlang-процессом (масштабируемость)
- Издатель может не знать, будет ли сообщение доставлено в очередь

### Типы Exchange

RabbitMQ поддерживает несколько типов exchange:

- **Direct** — маршрутизация по точному совпадению routing key
- **Topic** — маршрутизация по шаблону routing key
- **Fanout** — рассылка во все связанные очереди
- **Headers** — маршрутизация на основе заголовков сообщения

## Queue (Очередь)

Хранит ссылки на сообщения (в памяти или на диске) и отдает копии сообщений потребителям.

### Характеристики

- Может быть привязана к нескольким Exchange
- Может обслуживать несколько Consumer одновременно

## Binding (Привязка)

Правило маршрутизации сообщений от Exchange к Queue на основе routing key или других параметров.

### Особенности

- Exchange и Queue могут быть связаны несколькими Binding
- Один Exchange может быть привязан к нескольким Queue

## Connection и Channel

### Connection (Подключение)

TCP-соединение между клиентом и сервером RabbitMQ.

:::warning Важно
Не рекомендуется открывать новое соединение для каждой операции — это приводит к большим затратам ресурсов.
:::

### Channel (Канал)

Виртуальное соединение внутри Connection для параллельного выполнения команд.

:::warning Важно
Каналы должны быть постоянными, но могут закрываться при ошибках протокола.
:::

#### Особенности

- Каждый канал изолирован и создает отдельный Erlang-процесс
- Для параллельной работы открывайте несколько каналов
- Одно подключение может иметь множество каналов (multiplexing)
- Больше каналов = больше памяти для управления соединением

## Producer и Consumer

### Producer (Издатель)

Отправляет сообщения в Exchange с указанием routing key. Не знает о существовании Queue.

### Consumer (Потребитель)

Подписывается на Queue, получает и обрабатывает сообщения, отправляет подтверждение (ack) после обработки.

## Подтверждение доставки (Acknowledgment)

Consumer должен отправить подтверждение (ack), чтобы сообщение было удалено из Queue.

### Режимы подтверждения

- **Manual ack** — явное подтверждение после обработки
- **Auto ack** — автоматическое подтверждение при получении

:::tip Рекомендация
Используйте manual ack для критически важных сообщений.
:::

## Протокол AMQP

AMQP (Advanced Message Queuing Protocol) — открытый протокол для передачи сообщений между компонентами системы. Протокол работает поверх TCP/IP и обеспечивает:

- Надежную доставку сообщений
- Маршрутизацию сообщений
- Распределение потоков данных
- Подписку на типы сообщений

## RPC (Remote Procedure Call)

Все взаимодействия с RabbitMQ основаны на RPC. Команды AMQP — это классы и методы:

- `Connection.Start` — вызов метода `Start` класса `Connection`
- `Channel.Open` — открытие канала

## Дополнительные ресурсы

- [Официальная документация](https://www.rabbitmq.com/documentation.html)
- [Статья на Habr: RabbitMQ. Часть 1. Introduction](https://habr.com/ru/articles/488654/)
- [Статья на Habr: RabbitMQ. Часть 2. Разбираемся с Exchanges](https://habr.com/ru/articles/489086/)
